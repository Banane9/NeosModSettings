using FrooxEngine;
using FrooxEngine.UIX;
using BaseX;
using HarmonyLib;
using NeosModLoader;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace NeosModSettings
{
    public class NeosModSettings : NeosMod
    {
        public override string Name => "NeosModSettings";
        public override string Author => "badhaloninja";
        public override string Version => "1.0.0";
        public override string Link => "https://github.com/badhaloninja/NeosModSettings";


        [AutoRegisterConfigKey]
        private readonly ModConfigurationKey<bool> TEST_BOOL = new ModConfigurationKey<bool>("testBool", "Test Boolean", () => true);

        [AutoRegisterConfigKey]
        private readonly ModConfigurationKey<string> TEST_STRING = new ModConfigurationKey<string>("testStr", "Test String", () => "Value");


        [AutoRegisterConfigKey]
        private readonly ModConfigurationKey<int4> TEST_INTMATRIX = new ModConfigurationKey<int4>("testIntMatrix", "Test int4", () => new int4(12), valueValidator: (value) => value.x == 12);

        [AutoRegisterConfigKey]
        private readonly ModConfigurationKey<float3x3> TEST_float3x3 = new ModConfigurationKey<float3x3>("testFloat3x3", "Test float3x3", () => float3x3.Identity);


        [AutoRegisterConfigKey]
        private readonly ModConfigurationKey<color> TEST_COLOR = new ModConfigurationKey<color>("testColor", "Test Color", () => color.Blue);

        [AutoRegisterConfigKey]
        private readonly ModConfigurationKey<Type> TEST_TYPE = new ModConfigurationKey<Type>("testType", "Test Type", () => typeof(Button));

        private static Dictionary<string, NeosModBase> configuredModList = new Dictionary<string, NeosModBase>();

        private static Slot optionsRoot;

        public override void OnEngineInit()
        {
            ModConfiguration.OnAnyConfigurationChanged += OnConfigurationChanged;

            Harmony harmony = new Harmony("me.badhaloninja.NeosModSettings");
            harmony.PatchAll();
        }




        [HarmonyPatch(typeof(UserspaceScreensManager))]
        class ModSettingsScreen
        {
            [HarmonyPostfix]
            [HarmonyPatch("SetupDefaults")]
            public static void SetupDefaults(UserspaceScreensManager __instance)
            { // If you don't have an account this will be generated
                Msg("SetupDefaults");
                RadiantDash componentInParents = __instance.Slot.GetComponentInParents<RadiantDash>();
                
                RadiantDashScreen radiantDashScreen = componentInParents.AttachScreen("NML", color.Orange, NeosAssets.Graphics.Icons.Dash.Tools);
                generateNMLScreen(radiantDashScreen);
            }

            [HarmonyPostfix]
            [HarmonyPatch("OnLoading")] 
            public static void OnLoading(UserspaceScreensManager __instance)
            { // If you have an account/sign in OnLoading triggers and replaces the contents generated by SetupDefaults
                Msg("OnLoading");
                RadiantDash componentInParents = __instance.Slot.GetComponentInParents<RadiantDash>();

                RadiantDashScreen radiantDashScreen = componentInParents.AttachScreen("NML", color.Orange, NeosAssets.Graphics.Icons.Dash.Tools);
                generateNMLScreen(radiantDashScreen);
            }

            private static void generateNMLScreen(RadiantDashScreen radiantDashScreen)
            {
                Slot screenSlot = radiantDashScreen.Slot;
                screenSlot.OrderOffset = 70; // Settings Screen is 60, Exit screen is set to int.MaxValue 
                screenSlot.PersistentSelf = false; // So it doesn't save

                var ui = new UIBuilder(radiantDashScreen.ScreenCanvas);
                RadiantUI_Constants.SetupDefaultStyle(ui);
                ui.Image(UserspaceRadiantDash.DEFAULT_BACKGROUND);

                ui.NestInto(ui.Empty("Split"));
                ui.SplitHorizontally(0.25f, out RectTransform left, out RectTransform right);


                ui.NestInto(left); // Mod List
                left.Slot.AttachComponent<Image>().Tint.Value = new color(0.05f, 0.75f);

                ui.HorizontalFooter(56f, out RectTransform modsFooter, out RectTransform modsContent);
                ui.NestInto(modsFooter);
                var saveAllBtn = ui.Button("Save All");
                saveAllBtn.LocalPressed += (btn, be) =>
                {
                    btn.LabelText = "Saving"; // Saves so fast this might be unnecessary 

                    var errCount = saveAllConfigs();

                    if (errCount == 0)
                    { // Show Saved! for 1 second
                        btn.LabelText = "Saved!";
                        btn.RunInSeconds(1f, () => btn.LabelText = "Save All");
                        return;
                    };
                    // Errors

                    btn.Enabled = false;
                    btn.LabelText = $"<color=red>{errCount} Errors\n(Check Logs)</color>";
                    btn.RunInSeconds(5f, () => // Show error count for 5 seconds
                    {
                        btn.Enabled = true;
                        btn.LabelText = "Save All";
                    });
                };


                ui.NestInto(modsContent);
                ui.ScrollArea(Alignment.TopCenter);
                ui.VerticalLayout(4f);

                ui.FitContent(SizeFit.Disabled, SizeFit.PreferredSize);

                RadiantUI_Constants.SetupDefaultStyle(ui);
                ui.Style.PreferredHeight = 90f;
                GenerateModButtons(ui);


                // Config Panel
                ui.NestInto(right);

                buildNMSInfo(ui); // Shows when no mod is selected

                

                // Mod info footer
                ui.HorizontalFooter(100f, out RectTransform footer, out RectTransform content);
                ui.NestInto(footer);
                var splits = ui.SplitHorizontally(0.25f, 0.65f, 0.1f);

                ui.NestInto(splits[0]); //Author
                var authorText = ui.Text("");
                authorText.Content.SyncWithVariable("Config/SelectedModAuthor");

                ui.NestInto(splits[1]); //Link

                var linkText = ui.Text("");
                var hyperlink = linkText.Slot.AttachComponent<Hyperlink>();
                hyperlink.URL.SyncWithVariable("Config/SelectedModUri");
                linkText.Content.DriveFrom(hyperlink.URL, "{0}"); // Drive the text 
                var hyperlinkButton = linkText.Slot.AttachComponent<Button>();
                hyperlinkButton.SetupBackgroundColor(linkText.Color); // Drive the text color

                ui.NestInto(splits[2]); // Version

                var versionText = ui.Text("");
                versionText.Content.SyncWithVariable("Config/SelectedModVersion");
                // Mod info footer end



                // Setup config root
                RadiantUI_Constants.SetupDefaultStyle(ui);
                ui.NestInto(content);

                ui.ScrollArea(Alignment.TopCenter);
                ui.VerticalLayout(4f, 24f);

                ui.FitContent(SizeFit.Disabled, SizeFit.PreferredSize);

                ui.Style.PreferredHeight = 45f;


                // Setup Variables
                optionsRoot = ui.Root;

                var space = screenSlot.AttachComponent<DynamicVariableSpace>();
                space.SpaceName.Value = "Config";

                var selectedModVar = screenSlot.AttachComponent<DynamicValueVariable<string>>();
                selectedModVar.VariableName.Value = "Config/SelectedMod";
                selectedModVar.Value.OnValueChange += generateConfigItems; // Regen Config items on change
            }

            private static void generateConfigItems(SyncField<string> syncField)
            {
                optionsRoot.DestroyChildren();

                // Clear footer
                optionsRoot.TryWriteDynamicValue<string>("Config/SelectedModAuthor", null);
                optionsRoot.TryWriteDynamicValue<string>("Config/SelectedModVersion", null);
                optionsRoot.TryWriteDynamicValue<Uri>("Config/SelectedModUri", null);

                if (String.IsNullOrWhiteSpace(syncField.Value) || !configuredModList.TryGetValue(syncField.Value, out NeosModBase mod) || mod == null)
                {
                    return;
                }

                // Set footer values
                optionsRoot.TryWriteDynamicValue<string>("Config/SelectedModAuthor", mod.Author);
                optionsRoot.TryWriteDynamicValue<string>("Config/SelectedModVersion", mod.Version);

                Uri.TryCreate(mod.Link, UriKind.RelativeOrAbsolute, out Uri modUri); // Catch invalid uris just incase
                optionsRoot.TryWriteDynamicValue<Uri>("Config/SelectedModUri", modUri);


                UIBuilder ui = new UIBuilder(optionsRoot);
                RadiantUI_Constants.SetupDefaultStyle(ui);
                ui.Style.PreferredHeight = 24f;

                ModConfiguration config = mod.GetConfiguration();

                foreach (ModConfigurationKey key in config.ConfigurationItemDefinitions)
                { // Generate field for every supported config
                    if (key.InternalAccessOnly) continue;
                    generateConfigFieldOfType(key.ValueType(), ui, syncField.Value, config, key);

                    continue;
                }


                RadiantUI_Constants.SetupDefaultStyle(ui);
                ui.Style.PreferredHeight = 24f;
                var defaultsBtn = ui.Button("Reset Default Settings");
                defaultsBtn.RequireLockInToPress.Value = true;
                defaultsBtn.LocalReleased += (btn, be) =>
                {
                    foreach (ModConfigurationKey key in config.ConfigurationItemDefinitions)
                    { // Generate field for every supported config
                        if (key.InternalAccessOnly) continue;
                        config.Unset(key);

                        // Get default type
                        object value = (key.TryComputeDefault(out object defaultValue)) ? 
                            defaultValue : 
                            typeof(Coder<>).MakeGenericType(key.ValueType()).GetProperty("Default").GetValue(null); // Feel free do to a pull request at any time *:*)

                        optionsRoot.TryWriteDynamicValueOfType(key.ValueType(), $"Config/{syncField.Value}.{key.Name}", value);
                    }
                };
            }

            private static void buildNMSInfo(UIBuilder ui)
            {
                Slot descRoot = ui.Next("Description");
                ui.Nest();
                string Desc = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer ut lectus turpis. Aliquam auctor mattis enim vitae sagittis. In purus elit, mollis quis urna eget, maximus varius erat. Praesent pharetra lorem sed metus fringilla, sit amet iaculis ex gravida. Suspendisse interdum purus quam. Nam vitae libero egestas, volutpat leo in, maximus ex. Curabitur eget eros erat. Donec sed eros ut mi gravida eleifend. Suspendisse potenti.";
                ui.Text(Desc, alignment: Alignment.MiddleCenter);
                ui.NestOut();
                var dynVar = ui.Root.AttachComponent<DynamicValueVariable<string>>();
                dynVar.VariableName.Value = "Config/SelectedMod";

                var equalityDriver = ui.Root.AttachComponent<ValueEqualityDriver<string>>();
                equalityDriver.Target.TrySet(descRoot.ActiveSelf_Field);
                equalityDriver.TargetValue.TrySet(dynVar.Value);
            }


            public static void generateConfigFieldOfType(Type type, UIBuilder ui, string ModName, ModConfiguration config, ModConfigurationKey key)
            { // Generics go brr
                var method = typeof(ModSettingsScreen).GetMethod(nameof(generateConfigField));
                var genMethod = method.MakeGenericMethod(type);
                object[] args = new object[] { ui, ModName, config, key };
                genMethod.Invoke(null, args);
                return;
            }
            public static void generateConfigField<T>(UIBuilder ui, string ModName, ModConfiguration config, ModConfigurationKey key)
            {
                Debug($"GenerateConfigField for type ${nameof(T)} is valid: ${DynamicValueVariable<T>.IsValidGenericType}");
                if (!DynamicValueVariable<T>.IsValidGenericType) return; // Check if supported type

                ui.Style.MinHeight = 24f;
                bool flag = typeof(T).IsMatrixType();
                if (flag)
                {
                    int2 matrixDimensions = typeof(T).GetMatrixDimensions();
                    ui.Style.MinHeight = (float)(matrixDimensions.y * 24 + (matrixDimensions.y - 1) * 4);
                }

                Slot root = ui.Next("ConfigElement");
                ui.Nest();


                var dynvar = root.AttachComponent<DynamicValueVariable<T>>();
                dynvar.VariableName.Value = $"Config/{ModName}.{key.Name}";

                dynvar.Value.Value = config.TryGetValue(key, out object cv) ? (T)cv : Coder<T>.Default; // Set initial value
                dynvar.Value.OnValueChange += (syncF) => // Cursed solution, I know
                { // Update config
                    var typedKey = key as ModConfigurationKey<T>;

                    bool isSet = config.TryGetValue(typedKey, out T configValue);
                    if (isSet && configValue.Equals(syncF.Value)) return; // Skip if new value is equal to old
                                                                          //Msg($"DirectAccessOnly: {syncF.DirectAccessOnly}, FoundLink: {syncF.ActiveLink != null}, FoundDirectLink: {syncF.DirectLink != null}, FoundInheritedLink: {syncF.InheritedLink != null}, CanWrite: {syncF.CanWrite}, BD: {syncF.IsBlockedByDrive}, Driven: {syncF.IsDriven}, Hooked: {syncF.IsHooked}, Linked: {syncF.IsLinked}, HC: {syncF.IsWithinHookCallback}");

                    if (!key.Validate(syncF.Value))
                    { // Fallback if validation fails
                        Debug($"Failed Validation for {dynvar.VariableName.Value}");
                        // Writing to the variable here breaks the editor 
                        return; // Skip updating config
                    }

                    config.Set(key, syncF.Value, "NeosModSettings variable change");
                };

                string varName = (String.IsNullOrWhiteSpace(key.Description)) ? key.Name : key.Description; // If description is empty use name

                RadiantUI_Constants.SetupDefaultStyle(ui);
                ui.Style.TextAutoSizeMax = 20f;
                ui.HorizontalElementWithLabel<Component>(varName, 0.7f, () =>
                {
                    SyncMemberEditorBuilder.Build(dynvar.Value, null, dynvar.GetSyncMemberFieldInfo(4), ui);
                    // Can't recolor fields because PrimitiveMemeberEditor sets the colors on changes

                    ui.Root.ForeachComponentInChildren<Text>((text) =>
                    { // Make value path text readable
                        if (text.Slot.Parent.GetComponent<Button>() != null) return; // Ignore text under buttons
                        text.Color.Value = RadiantUI_Constants.TEXT_COLOR;
                    });


                    // This is horrid, I have given up trying to get it to work in the dynvar on changed event
                    // And because of matrixes there can be multiple memberEditors
                    // Lambdas all the way down!
                    ui.Root.ForeachComponentInChildren<PrimitiveMemberEditor>((pme) => // ;-;
                    { // Get every text editor from each primitive member editor
                        SyncRef<TextEditor> _textEditor = pme.GetSyncMember(7) as SyncRef<TextEditor>; // Get TextEditor from PrimitiveMemberEditor
                        if (_textEditor == null) return;
                        _textEditor.Target.LocalEditingFinished += (te) =>
                        { // Value Validation
                            bool isSet = config.TryGetValue(key, out object configValue);
                            if (!key.Validate(dynvar.Value.Value))
                            { // Fallback if validation fails
                                Debug($"Failed Validation for {dynvar.VariableName.Value}");
                                dynvar.Value.Value = (isSet) ? (T)configValue : Coder<T>.Default; // Set to old value if is set Else set to default for that value
                                return;
                            }
                        };
                    });

                    return null; // HorizontalElementWithLabel requires a return type that implements a component
                });

                ui.NestOut();
            }
            private static void GenerateModButtons(UIBuilder ui)
            {
                List<NeosModBase> mods = new List<NeosModBase>(ModLoader.Mods());
                List<NeosModBase> configuredMods = mods
                    .Where(m => m.GetConfiguration() != null) // Get all mods with configs
                    .ToList();


                var dVar = ui.Root.GetComponentOrAttach<DynamicValueVariable<string>>(out bool varAttached);
                if (varAttached)
                {
                    dVar.VariableName.Value = "Config/SelectedMod";
                }
                bool flag = configuredModList.Count == 0;
                foreach (NeosModBase mod in configuredMods)
                {
                    int configCount = mod.GetConfiguration().ConfigurationItemDefinitions
                        .Where(c => !c.InternalAccessOnly)
                        .ToList()
                        .Count;
                    Debug($"{mod.Name} has {configCount} available config items");
                    if (configCount == 0) continue; // Skip if it only has InternalAccessOnly definitions

                    string modKey = $"{mod.Author}.{mod.Name}";

                    if (flag) // Incase you log out and log in
                    {
                        configuredModList.Add(modKey, mod);
                    }

                    var button = ui.Button(mod.Name);

                    var deselected = new OptionDescription<string>(null, label: mod.Name, buttonColor: RadiantUI_Constants.BUTTON_COLOR);
                    var selected = new OptionDescription<string>(modKey, label: mod.Name, buttonColor: RadiantUI_Constants.HIGHLIGHT_COLOR);

                    button.ConvertTintToAdditive();
                    button.SetupValueToggle(dVar.Value, modKey, selected, deselected);
                }

                Msg($"{configuredModList.Count} found mods with configs");
            }

            private static int saveAllConfigs()
            {
                Debug("Save All Configs");
                int errCount = 0;
                foreach (NeosModBase mod in configuredModList.Values)
                { // Iterate over every mod with configs
                    Debug($"Saving Config for {mod.Name}");
                    try
                    {
                        mod.GetConfiguration().Save(); // Save config
                    }
                    catch (Exception e)
                    {
                        errCount++;
                        Error($"Failed to save Config for {mod.Name}");
                        Error(e);
                    }
                }
                return errCount;
            }

        }





        private void OnConfigurationChanged(ConfigurationChangedEvent @event)
        {
            Debug($"ConfigurationChangedEvent fired for mod \"{@event.Config.Owner.Name}\" Config \"{@event.Key.Name}\"");
            if (optionsRoot == null) return;

            if (!@event.Config.TryGetValue(@event.Key, out object value)) return;

            string modName = $"{@event.Config.Owner.Author}.{@event.Config.Owner.Name}";
            optionsRoot.RunSynchronously(() =>
            { 
                optionsRoot.TryWriteDynamicValueOfType(@event.Key.ValueType(), $"Config/{modName}.{@event.Key.Name}", value);
            });
        }
    }
}